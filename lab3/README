README for Assignment 3
===========================================
|  Scott Harvey     cse533-11  108272691  |
|  Michael Salerno  cse533-8   108512298  |
===========================================

When running the client and ODR the user can type ^D to terminate.
The server doesn't have that.


Special Cases:
1. ***  PARTIAL FIX in commit eecc442bf839576fc6f3f5ca85936b5eb5dd8178  ***
    If two clients on a vm1 both msg_send() to vm5, and vm1 has no route to vm5,
  then both msg_send()'s will generate equivalent RREQs. We reason that this
  is not a problem.

2. *** FIX to immediately drop the route: ***
    If a msg_send() has set force_redisc we do not immediately drop the route
  from our routing table. Instead we send a RREQ with the force_redisc flag
  set. The corresponding RREP that eventually comes back will also have the
  force_redisc flag set, causing us to forcefully update our route.

=======================
Outline of ODR Program:
=======================
select(unixfd/rawfd):
  unixfd:
    1. Local dst IP: Forward to local dst port.
    2. Remote dst IP:
        a. get_route(dst_IP)
            - force_redisc/no route/stale:  send RREQ over rawfd
            - had a route:                  send DATA over rawfd

  rawfd:
    * RREQ: see ODR Overview
    * RREP: see ODR Overview
    * DATA: see ODR Overview

==============
Routing Table:
==============
-----------------------------------------------------------------------
| DestIP | BroadcastID | NextHop(MAC) | IfIndex | NumHops | Timestamp |
-----------------------------------------------------------------------



==========================================
============== ODR Overview ==============
==========================================

On RREQ received (Overview):
============================
1. If we are the dest node OR we have a non-stale route to dest.
    * Then we RREP.

2. Else we send RREQ on all interfaces except the one the RREQ arrived on.


On RREQ received (Detailed):
============================
1. Update Reverse Route in routing table:
    a. Always do: route.broadcast_id = RREQ.broadcast_id ?????
    b. If RREQ.hops <= route.hops || RREQ.force_redisc then update route.
        1. Update the NxtHop to the src MAC in the sockaddr_ll.
    * Set EFF_ROUTE if no prev route to src or route was stale.
    * Set EFF_ROUTE if RREQ.hops < route.hops (more efficient route).

if(RREQ.broadcast_id > route.broadcast_id || EFF_ROUTE):  <--- same thing as add_route returning > -1
    2. RREP generation.
        Only if(!RREQ.do_not_rrep && (!RREQ.force_redisc || i_am_dest)):
        a. If I have route to RREQ.dst_ip:  then send RREP
        b. If I am dest and RREQ.force_redisc, keep RREQ.force_redisc set

    3. RREQ flooding. Only if(EFF_ROUTE):
        a. If we sent RREP, set the RREQ.rrep_sent flag.
        b. Send RREQ on all interfaces except the source interface.


On RREP received (Detailed):
============================
1.  If the RREP was not for you, relay it using the path in the table
    that was added when the corresponding RREQ was received.

2.  Add/Update the path to the destination. If the route is suboptimal,
    DO NOT update the table and DO NOT relay the information to the destination. (what about when force_redsc??)

?.  "maintaining a route and its associated timestamp in
    the table in response to RREPs received is done in the same manner described
    above for RREQs."

On DATA received (Detailed):
===================================
1.  make sure to add the path to the source to the table.
    WILL LOSE POINTS

On ANYTHING transmitted (Detailed):
===================================
1.  if (now >= ts || FLAGS || missing): send RREQ then send
    else: update the ts and send
